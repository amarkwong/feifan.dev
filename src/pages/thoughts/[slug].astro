---
import Layout from '../../layouts/Layout.astro';
import { fetchNotionArticle, fetchChildPages } from '../../lib/notion';
import { blogEntries, blogCollections } from '../../data/blogEntries';
import { deriveNotionEmbedSrc, deriveNotionSlug } from '../../lib/notionEmbed';

interface EmbedProps {
  notionPageId: string;
  fallbackTitle?: string;
  fallbackUrl?: string | null;
}

interface EmbedPath {
  params: { slug: string };
  props: EmbedProps;
}

export async function getStaticPaths() {
  const usedSlugs = new Set<string>();
  const paths: EmbedPath[] = [];

  const reserveSlug = (desired: string, fallback?: string): string => {
    let candidate = desired || fallback || 'note';
    let counter = 1;
    while (usedSlugs.has(candidate)) {
      candidate = `${desired}-${counter++}`;
    }
    usedSlugs.add(candidate);
    return candidate;
  };

  async function registerManualEntries() {
    await Promise.all(
      blogEntries
        .filter((entry) => Boolean(entry.notionPageId))
        .map(async (entry) => {
          const article = await fetchNotionArticle(entry.notionPageId);
          if (!article?.publicUrl) return;
          const slugBase = deriveNotionSlug({
            publicUrl: article.publicUrl,
            title: article.title,
            fallbackSlug: entry.slug,
            pageId: entry.notionPageId,
          });
          const slug = reserveSlug(slugBase);
          paths.push({
            params: { slug },
            props: {
              notionPageId: entry.notionPageId,
              fallbackTitle: article.title ?? entry.titleOverride ?? entry.slug,
              fallbackUrl: article.publicUrl,
            },
          });
        })
    );
  }

  async function registerCollections() {
    const collectionChildren = (
      await Promise.all(blogCollections.map(async (collection) => fetchChildPages(collection.parentPageId)))
    ).flat();

    await Promise.all(
      collectionChildren.map(async (child) => {
        const article = await fetchNotionArticle(child.id);
        const publicUrl = article?.publicUrl || child.publicUrl;
        if (!publicUrl) return;
        const slugBase = deriveNotionSlug({
          publicUrl,
          title: article?.title ?? child.title,
          fallbackSlug: child.title,
          pageId: child.id,
        });
  const slug = reserveSlug(slugBase, child.id);
        paths.push({
          params: { slug },
          props: {
            notionPageId: child.id,
            fallbackTitle: article?.title ?? child.title,
            fallbackUrl: publicUrl,
          },
        });
      })
    );
  }

  await Promise.all([registerManualEntries(), registerCollections()]);
  return paths;
}

const { notionPageId, fallbackTitle, fallbackUrl } = Astro.props as EmbedProps;
const article = notionPageId ? await fetchNotionArticle(notionPageId) : null;
const displayTitle = article?.title ?? fallbackTitle ?? 'Notebook entry';
const iframeSrc = deriveNotionEmbedSrc(article?.publicUrl ?? fallbackUrl, notionPageId);
---

<Layout title={`${displayTitle} — Thoughts — feifan.dev`}>
  <article class="embed-shell glass-panel">
    <header class="embed-header">
      <span class="chip">Notion deep-dive</span>
      <h1>{displayTitle}</h1>
      <div class="embed-meta">
        <a class="ghost-link" href="/thoughts" transition:animate="fade">← Back to thoughts</a>
        {iframeSrc && (
          <a class="ghost-link" href={iframeSrc} target="_blank" rel="noreferrer">
            Open in Notion ↗
          </a>
        )}
      </div>
    </header>
    {iframeSrc ? (
      <div class="iframe-shell">
        <iframe
          src={iframeSrc}
          title={displayTitle}
          loading="lazy"
          referrerpolicy="no-referrer"
          allowfullscreen
        ></iframe>
      </div>
    ) : (
      <p class="embed-error">
        This entry is private or no longer shared. Ping me if you need access.
      </p>
    )}
  </article>
</Layout>

<style>
  .embed-shell {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    padding: 2.5rem;
  }

  .embed-header h1 {
    margin: 0.35rem 0 0;
    font-size: clamp(2rem, 4vw, 2.75rem);
  }

  .embed-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-top: 0.75rem;
  }

  .iframe-shell {
    border: 1px solid var(--panel-border);
    border-radius: 18px;
    overflow: hidden;
    min-height: 70vh;
    box-shadow: var(--panel-shadow);
  }

  iframe {
    width: 100%;
    height: 80vh;
    border: 0;
    background: #fff;
  }

  @media (max-width: 720px) {
    .embed-shell {
      padding: 2rem;
    }
    iframe {
      height: 75vh;
    }
  }
</style>
